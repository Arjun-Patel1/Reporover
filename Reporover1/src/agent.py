from typing import TypedDict, List
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate
from langgraph.graph import StateGraph, END

from src.llm import get_llm
from src.tools.search_tool import CodeSearchTool
from src.tools.docker_tool import DockerTool
from src.tools.ast_parser import ASTParserTool
from src.utils.logger import setup_logger

# Initialize Logger
logger = setup_logger()

# --- 1. Define the State ---
class AgentState(TypedDict):
    query: str                      # User's bug report
    context: List[str]              # Retrieved code chunks
    plan: str                       # NEW: The Architect's step-by-step plan
    code_solution: str              # Code generated by agent
    test_output: str                # Docker output
    exit_code: int                  # 0 = Success, 1 = Fail
    error_analysis: str             # Feedback from Reviewer/Reflector
    supervisor_feedback: str        # Strategy from Supervisor
    retry_count: int                # Loop counter
    max_retries: int                # Safety limit
    review_status: str              # 'APPROVED' or 'REJECTED'

# --- 2. The Agent Class ---
class RepoRoverAgent:

    def __init__(self, repo_path: str):
        self.llm = get_llm()
        self.search_tool = CodeSearchTool(repo_path)
        self.docker_tool = DockerTool(repo_path=repo_path)
        self.max_retries = 3

    # --- Node 1: Retriever ---
    def retrieve_node(self, state: AgentState):
        logger.info(f"üîç Retrieving context for query: {state['query']}")
        results = self.search_tool.search(state["query"])
        return {"context": results}

    # --- Node 2: Planner (NEW: The Architect) ---
    def planner_node(self, state: AgentState):
        logger.info("üß† Architect is planning the solution...")
        
        context_str = "\n".join(state.get("context", []))
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a Senior Software Architect. You do not write code; you write plans."),
            ("human", """
            User Query: {query}
            
            Repo Context:
            {context}
            
            Create a numbered STEP-BY-STEP PLAN to solve this.
            - Focus on files, paths, and libraries needed.
            - Be specific (e.g., "Step 1: Import os. Step 2: Check if README exists...").
            - Do not provide code blocks, just English instructions.
            
            Output ONLY the plan.
            """)
        ])
        
        chain = prompt | self.llm
        response = chain.invoke({
            "query": state["query"], 
            "context": context_str
        })
        
        logger.info(f"üìù Plan created: {response.content[:100]}...")
        return {"plan": response.content}

    # --- Node 3: Coder ---
    def coder_node(self, state: AgentState):
        attempt = state.get('retry_count', 0) + 1
        logger.info(f"‚úçÔ∏è  Generating code (Attempt {attempt})...")
        
        context_str = "\n\n".join(state.get("context", []))
        previous_error = state.get("error_analysis", "None")
        supervisor_hint = state.get("supervisor_feedback", "")
        plan = state.get("plan", "No plan provided.") # Get the plan
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are an expert Python developer. Follow the Architect's plan exactly."),
            ("human", """
            User Query: {query}
            
            ARCHITECT'S PLAN (MUST FOLLOW):
            {plan}
            
            Context:
            {context}
            
            Reviewer/Supervisor Feedback:
            {previous_error}
            {supervisor_hint}
            
            INSTRUCTIONS:
            1. Write a complete python script named `main.py`.
            2. Implement the steps in the plan.
            3. Include a test case.
            4. OUTPUT ONLY CODE. No markdown.
            """)
        ])
        
        chain = prompt | self.llm
        response = chain.invoke({
            "query": state["query"], 
            "context": context_str,
            "previous_error": previous_error,
            "supervisor_hint": supervisor_hint,
            "plan": plan
        })
        
        code = response.content.replace("```python", "").replace("```", "").strip()
        return {"code_solution": code}

    # --- Node 4: Reviewer ---
    def reviewer_node(self, state: AgentState):
        logger.info("üßê Reviewer is inspecting the code...")
        code = state["code_solution"]
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a Senior Code Reviewer."),
            ("human", """
            Review this Python code for the query: "{query}"
            
            CODE:
            {code}
            
            Evaluation Criteria:
            1. Does it follow the user's intent?
            2. Is it safe?
            3. Does it handle basic errors (file not found)?
            
            If it looks solid, reply with: APPROVED
            If it is broken, reply with: REJECTED: <short reason>
            """)
        ])
        
        chain = prompt | self.llm
        response = chain.invoke({"query": state["query"], "code": code})
        decision = response.content.strip()
        
        if "APPROVED" in decision:
            logger.info("‚úÖ Code Approved by Reviewer.")
            return {"review_status": "APPROVED", "error_analysis": ""}
        else:
            logger.warning(f"‚ùå Code Rejected: {decision[:100]}...")
            return {
                "review_status": "REJECTED", 
                "error_analysis": decision,
                "retry_count": state.get("retry_count", 0) + 1
            }

    # --- Node 5: Supervisor ---
    def supervisor_node(self, state: AgentState):
        logger.info("üõÇ Supervisor is intervening...")
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are the Team Lead. The Coder is stuck."),
            ("human", """
            User Query: {query}
            Reviewer Rejection: {error}
            
            Provide a ONE-SENTENCE hint to help the Coder fix this.
            """)
        ])
        
        chain = prompt | self.llm
        response = chain.invoke({
            "query": state["query"], 
            "error": state["error_analysis"]
        })
        
        return {"supervisor_feedback": response.content}

    # --- Node 6: Executor ---
    def executor_node(self, state: AgentState):
        logger.info("üöÄ Running code in Docker...")
        result = self.docker_tool.run_code(state["code_solution"])
        return {
            "exit_code": result["exit_code"],
            "test_output": result["output"]
        }

    # --- Node 7: Reflector ---
    def reflector_node(self, state: AgentState):
        exit_code = state["exit_code"]
        retry_count = state.get("retry_count", 0) + 1
        
        if exit_code == 0:
            logger.info("üéâ Test PASSED!")
            return {"exit_code": 0}
        
        logger.warning(f"üí• Runtime Failure (Exit {exit_code}). Analyzing...")
        return {
            "error_analysis": f"Runtime Error: {state['test_output']}",
            "retry_count": retry_count
        }

    # --- Edge Logic ---
    def check_review(self, state: AgentState):
        if state["review_status"] == "APPROVED":
            return "execute"
        elif state["retry_count"] >= self.max_retries:
            return "end"
        else:
            return "supervisor"

    def check_execution(self, state: AgentState):
        if state["exit_code"] == 0:
            return "success"
        elif state["retry_count"] >= self.max_retries:
            return "end"
        else:
            return "retry"

    # --- Graph Construction ---
    def build_graph(self):
        workflow = StateGraph(AgentState)
        
        # Add Nodes
        workflow.add_node("retrieve", self.retrieve_node)
        workflow.add_node("planner", self.planner_node)  # <--- NEW NODE
        workflow.add_node("coder", self.coder_node)
        workflow.add_node("reviewer", self.reviewer_node)
        workflow.add_node("supervisor", self.supervisor_node)
        workflow.add_node("execute", self.executor_node)
        workflow.add_node("reflect", self.reflector_node)
        
        # Set Flow: Retrieve -> Planner -> Coder
        workflow.set_entry_point("retrieve")
        workflow.add_edge("retrieve", "planner")
        workflow.add_edge("planner", "coder")
        workflow.add_edge("coder", "reviewer")
        
        # Conditional Edges
        workflow.add_conditional_edges(
            "reviewer",
            self.check_review,
            {
                "execute": "execute",
                "supervisor": "supervisor",
                "end": END
            }
        )
        
        workflow.add_edge("supervisor", "coder")
        workflow.add_edge("execute", "reflect")
        
        workflow.add_conditional_edges(
            "reflect",
            self.check_execution,
            {
                "success": END,
                "retry": "coder",
                "end": END
            }
        )
        
        return workflow.compile()